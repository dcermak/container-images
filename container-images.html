<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Demystifying Containers and Container Images</title>
<meta name="author" content="Dan ƒåerm√°k"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./node_modules/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./node_modules/reveal.js/dist/theme/simple.css" id="theme"/>

<link rel="stylesheet" href="./node_modules/@fortawesome/fontawesome-free/css/all.min.css"/>

<link rel="stylesheet" href="./custom-style.css"/>
<link rel="stylesheet" href="./node_modules/reveal.js/plugin/highlight/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './node_modules/reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h2 class="title">Demystifying Containers and Container Images</h2>
<p class="subtitle" style="color: Gray;"></p>
<p class="author">Dan ƒåerm√°k</p>
<div style="float:left"><a href="https://events.linuxfoundation.org/open-source-summit-europe/" target="_blank"><img src="./media/OSS-EU-logo-bg.svg" height="100px"/></a></div>
<div style="float:right;font-size:35px;"><p xmlns:dct="http://purl.org/dc/terms/" xmlns:cc="http://creativecommons.org/ns#"><a href="https://creativecommons.org/licenses/by/4.0" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">
CC BY 4.0 <i class="fab fa-creative-commons"></i> <i class="fab fa-creative-commons-by"></i></a></p></div>
</section>
<section>
<section id="slide-org31b26eb">
<h2 id="org31b26eb">Follow Along</h2>
<p>
<img src="./media/qr.svg" height="300px"/>
</p>

<p>
<i class="fa-solid fa-person-chalkboard"></i> <a href="https://dcermak.github.io/container-images/container-images.html"><code>dcermak.github.io/container-images</code></a>
</p>
</section>
</section>
<section>
<section id="slide-orgb21b4eb">
<h2 id="orgb21b4eb"><code>who -u</code></h2>
<p>
Dan ƒåerm√°k
</p>

<p>
 <div style="float:center">
 <table class="who-table">
 <tr><td><i class="fab fa-suse"></i></td><td> Software Developer @SUSE</td></tr>
 <tr><td><i class="fab fa-fedora"></i></td><td> i3 SIG, Package maintainer</td></tr>
 <tr><td><i class="far fa-heart"></i></td><td> Developer Tools, Testing and Documentation, Home Automation</td></tr>
 <tr></tr>
 <tr></tr>
 <tr><td><i class="fa-solid fa-globe"></i></td><td> <a href="https://dancermak.name/">https://dancermak.name</a></td></tr>
 <tr><td><i class="fab fa-github"></i></td><td> <a href="https://github.com/dcermak/">dcermak</a> </td></tr>
 <tr><td><i class="fab fa-mastodon"></i></td><td> <a href="https://mastodon.social/@Defolos">@Defolos@mastodon.social</a></td></tr>
 <tr><td><i class="fab fa-bluesky"></i></td><td> <a href="https://bsky.app/profile/defolos.bsky.social">@defolos.bsky.social</a></td></tr>
 </table>
 </div>
</p>
</section>
</section>
<section>
<section id="slide-orga3468ed">
<h2 id="orga3468ed">Agenda</h2>
<ul>
<li><a href="#/slide-orgc9f7cab">Containers from Scratch</a></li>
<li><a href="#/slide-org09183a2">Docker &amp; Podman</a></li>
<li><a href="#/slide-org0a08ac2">Container Orchestration</a></li>
<li><a href="#/slide-org52ef7bd">Should I use containers?</a></li>

</ul>
</section>
</section>
<section>
<section id="slide-orgc9f7cab">
<h2 id="orgc9f7cab">Software Delivery: The Real Problem</h2>
<aside class="notes">
<ul>
<li>devs typically run "bleeding edge", production is a "stable" distribution
&rArr; version conflicts are guaranteed, especially subtle ones</li>
<li>debugging prod is "fun", so can't we ship "dev"?</li>

</ul>

</aside>

<ul>
<li class="fragment appear">Dev environment != Production environment</li>
<li class="fragment appear">Deploy &rArr; 2 days of debugging üò°</li>

</ul>

<blockquote  class="fragment (appear)">
<p>
Why can't we just ship the exact environment that works?
</p>
</blockquote>

<blockquote  class="fragment (appear)">
<p>
So you want a VM?
</p>
</blockquote>

<blockquote  class="fragment (appear)">
<p>
No‚Ä¶
</p>
</blockquote>
</section>
<section id="slide-orgf4b0556">
<h3 id="orgf4b0556">Attempt #1: Bundle Everything üì¶Ô∏è</h3>
<aside class="notes">
<ul>
<li>first idea: if the problem is environment differences, bundle the whole environment</li>
<li>chroot creates isolated filesystem view</li>

</ul>

</aside>

<ol>
<li class="fragment appear">Create dev: <code>rsync -avz --exclude=/dev/ / /dev/</code></li>
<li class="fragment appear">Install app: <code>chroot /dev make install</code></li>
<li class="fragment appear">Clean up: <code>chroot /dev/ make clean</code></li>
<li class="fragment appear">Package: <code>tar -czf app.tar.gz /dev</code></li>

</ol>
</section>
<section id="slide-org885bd25">
<h3 id="org885bd25">And deploy üöÄ</h3>
<ol>
<li class="fragment appear"><code>tar -xzf app.tar.gz -C /opt/</code></li>
<li class="fragment appear"><code>chroot /opt/dev/ /usr/local/bin/app.bin</code></li>

</ol>
</section>
<section id="slide-orge0b210d">
<h3 id="orge0b210d">üéâ Success?</h3>
<aside class="notes">
<ul>
<li>manual &rarr; bad</li>
<li>huge archives are unwieldy</li>
<li>build process inefficient</li>

</ul>

</aside>

<ul>
<li class="fragment appear">Manual process</li>
<li class="fragment appear">Huge tar files (entire OS + app) are unwieldy</li>
<li class="fragment appear">No process isolation</li>
<li class="fragment appear">No resource limits</li>
<li class="fragment appear">No network isolation</li>

</ul>
</section>
<section id="slide-org93d9536">
<h3 id="org93d9536">Attempt #2: Add Process Isolation (Linux Namespaces)</h3>
<aside class="notes">
<ul>
<li>chroot only isolates filesystem, not processes or network:
deployed app has full PID &amp; network access</li>
<li>Namespaces provide deeper isolation - exactly what containers need</li>
<li>introduced in 2002 (kernel 2.4), more added in 2006</li>
<li>container support finished in 2013: user namespace with kernel 3.8</li>
<li>user: separate user ids of namespace &amp; host, map uids between host &amp; namespace
&rArr; uid 0 in namespace is user who created namespace
(&rarr; see also <code>/etc/subuid</code>)</li>
<li>mnt: mount namespace, isolated mounts</li>
<li>pid: Process ID isolation, process that "created" the namespace gets PID 1 and
all other processes become its children (also of sub-namespaces)</li>
<li>net: each net inerface in one namespace</li>
<li>ipc: restrict SysV style IPC</li>
<li>uts - unix time sharing: set hostname &amp; domainname</li>
<li>cgroup (added in 4.6): hide cgroup path, i.e. process only sees relative
cgroup path of the namespace and no others</li>
<li>time (added in 5.6): set different system time</li>

<li>useful tool: lsns</li>
<li>namespaces can be nested &amp; inherit</li>

</ul>

</aside>

<p class="fragment (appear)">
Linux Namespaces provide kernel-level resource isolation
</p>

<ul>
<li class="fragment appear">user</li>
<li class="fragment appear">mnt</li>
<li class="fragment appear">pid</li>
<li class="fragment appear">net</li>
<li class="fragment appear">ipc</li>
<li class="fragment appear">uts</li>
<li class="fragment appear">cgroup</li>
<li class="fragment appear">time</li>

</ul>

</section>
<section id="slide-org93d9536-split">

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="shell" data-line-numbers='1-3|4-5|6-9'>$ unshare --user --map-root-user \
      --pid --fork --mount-proc \
      /bin/bash
# whoami
root
# ps -a
    PID TTY          TIME CMD
      1 pts/8    00:00:00 bash
    104 pts/8    00:00:00 ps
</code></pre>
</div>
</section>
<section id="slide-org08c975b">
<h3 id="org08c975b">Attempt #3: Add Resource Limits (cgroups)</h3>
<aside class="notes">
<ul>
<li>isolation in place, but no protection from resource consumption:
could eat all the RAM, consume too much CPU, no monitoring, no disk I/O limits, etc.</li>
<li>cgroups provide the missing piece - resource control and limits</li>
<li>started in 2006, merged in 2008 (2.6.24)</li>
<li>redesigned to v2 in 2016 (4.5)</li>

<li>resource limits like I/O, FS caches, CPU quota, open files</li>
<li>process prioritization</li>
<li>measure whole group resource usage &amp; freeze/restart it</li>

<li>nowadays used by userspace memory killers</li>
<li>modern DEs put each process into a cgroup &rarr; for oom-killers</li>

</ul>

</aside>

<p class="fragment (appear)">
cgroups (Control Groups) provide resource management:
</p>
<ul>
<li>Apply resource limits to processes</li>
<li>Measure resource usage</li>

</ul>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="shell" data-line-numbers='1|2|3-4'># cgcreate -g memory:memlimit
# cgset -r memory.max=1K memlimit
# cgexec -g memory:memlimit ls -al
Killed
</code></pre>
</div>
</section>
<section id="slide-org5414f06">
<h3 id="org5414f06">The Manual Approach Doesn't Scale</h3>
<p class="fragment (appear)">
We have:
</p>

<ul>
<li class="fragment appear">‚úîÔ∏è Filesystem isolation (chroot)</li>
<li class="fragment appear">‚úîÔ∏è Process isolation (namespaces)</li>
<li class="fragment appear">‚úîÔ∏è Resource limits (cgroups)</li>

</ul>

</section>
<section id="slide-org5414f06-split">

<p class="fragment (appear)">
We need:
</p>

<ul>
<li class="fragment appear">‚ùå Standardized container build process</li>
<li class="fragment appear">‚ùå Easy sharing and distribution</li>
<li class="fragment appear">‚ùå Automated namespace/cgroup/FS setup</li>
<li class="fragment appear">‚ùå Simple command-line interface</li>

</ul>
</section>
</section>
<section>
<section id="slide-org09183a2">
<h2 id="org09183a2">Introducing: Docker</h2>
<aside class="notes">
<ul>
<li>Docker directly addresses each of the pain points</li>
<li>show how Docker features map to manual problems</li>
<li>this is the payoff moment - all the technical details come together</li>

</ul>

</aside>

<ul>
<li class="fragment appear"><b>Standardized build process</b> ‚Üí <code>Dockerfile</code></li>
<li class="fragment appear"><b>Easy sharing/distribution</b> ‚Üí Docker Registry</li>
<li class="fragment appear"><b>Automated setup</b> ‚Üí <code>docker run</code></li>
<li class="fragment appear"><b>Simple interface</b> ‚Üí <code>docker</code> CLI</li>

</ul>

<p class="fragment (appear)">
<img src="./media/Docker_(container_engine)_logo.svg"/>
</p>
</section>
<section id="slide-orgff2d94e">
<h3 id="orgff2d94e">Container Image Build</h3>
<aside class="notes">
<ul>
<li>usually build is a multi-step process &rArr; how about caching?</li>
<li>also, launching five containers <b>must</b> not result in five full copies</li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="Dockerfile" data-line-numbers='2|3|4|5|'>FROM registry.opensuse.org/opensuse/tumbleweed
RUN zypper -n in python3
COPY . /src/
RUN pip install .
RUN make test
</code></pre>
</div>

<p class="fragment (appear)">
and we need some CoW
</p>
</section>
<section id="slide-orgbb1bd22">
<h3 id="orgbb1bd22">UnionFS</h3>
<aside class="notes">
<ul>
<li>final image constructed from individual layers</li>
<li>file precedence: "highest directory" over "lowest"</li>
<li>file removal: via whiteout files,
in overlayFS: character special file (device 0, 0), create via <code>mknod $path c 0 0</code>
oci tar archives prepend <code>.wh.</code>, empty file</li>
<li>directory removal: whiteout file
oci tar archives: <code>dir/.wh..wh..opq</code> empty file
in overlayFS: character special file in upper dir (again created via <code>mknod</code>)</li>

</ul>

<p>
catches:
</p>
<ul>
<li>you can never truly delete files</li>
<li>editing a file creates a full copy (unionFS works on a file level)</li>
<li>certain operations not atomic</li>
<li>directory renames are very ugly (delete + full copy)</li>

<li>try it locally with OverlayFS on Linux,
lowerdir: read only layers
upperdir: rw top dir (= container dir)
workdir: used for internal purposes (CoW)</li>

</ul>

</aside>

<p class="fragment (appear)">
<img src="./media/overlays.svg"/>
</p>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="bash" >mount -t overlay overlay \
      -o lowerdir=lower_3:lower_2:lower_1,\
         upperdir=upper,workdir=/work/ \
           merged
</code></pre>
</div>
</section>
<section id="slide-orgadbd6cd">
<h3 id="orgadbd6cd">Container Image Build</h3>
<aside class="notes">
<ul>
<li>fix the inconvenient build process</li>
<li>build runs <b>in</b> a container!</li>
<li>docker build standardized &amp; simplified the image build process via the
<code>Dockerfile</code></li>
<li>syntax is: <code>INSTRUCTION &lt;value&gt;</code></li>
<li>image build starts <code>FROM</code> an image specified using the same format as the
registry</li>
<li>each instruction creates a layer, changes put on top, build process relies
heavily on caching</li>
<li>container image is "just a bunch of tar balls"</li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="bash" >docker build .
</code></pre>
</div>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="Dockerfile" data-line-numbers='|1|3|4|6-9|11|12|'>FROM registry.opensuse.org/opensuse/tumbleweed

COPY . /src/
WORKDIR /src/

RUN zypper -n in python3-pip; \
    pip install . ; \
    zypper -n rm --clean-deps gcc; zypper -n clean; \
    rm -rf {/target,}/var/log/{alternatives.log,lastlog,tallylog,zypper.log,zypp/history,YaST2}

EXPOSE 80
CMD ["/usr/bin/python", "-m", "my-app"]
</code></pre>
</div>
</section>
<section id="slide-orge3e66f1">
<h3 id="orge3e66f1">Dockerfile</h3>
<aside class="notes">
<ul>
<li><code>FROM</code> - specifies the base image for the current build stage</li>
<li><code>COPY</code> - copy files from the current build context (the directory passed as last
CLI arg) or from other stage to current stage
<code>ADD</code> used to fill this use case, but discouraged nowadays</li>
<li><code>ENV</code>: set environment variables, global for rest of build stage &amp; final image</li>
<li><code>RUN</code>: execute arbitrary commands in the container image context, using the
default shell. Beware of shell escapes when creating multiline strings, often
resort to hacks like <a href="https://stackoverflow.com/a/33439625">ksh93 ANSI-C quoting</a>
supports also flags like mounting secrets or setting the network</li>
<li><code>VOLUME</code>: declares a directory as a volume, everything in it is temporary from
this layer on, when launching the container a temporary volume is created</li>
<li><code>WORKDIR</code>: sets the cwd for all subsequent instructions &amp; for entrypoint/cmd</li>
<li><code>EXPOSE</code>: defines network ports to be exposed, but only documentation. protocol
can be specified, defaults to TCP if not supplied. Ports still have to be
exposed via <code>-p $hostPort:$ctrPort</code> or all via <code>-P</code></li>
<li><code>USER</code>: defines the user for entrypoint &amp; cmd and subsequent <code>RUN</code> instructions,
must exist in the image!</li>
<li><code>CMD</code>: default args for the entrypoint</li>
<li><code>ENTRYPOINT</code>: defines binary launched as PID 1</li>

</ul>

<p>
additional directives:
</p>
<ul>
<li><code>ARG</code> - set build arguments, can be passed via <code>--build-arg "USER=me"</code> CLI flag</li>
<li><code>LABEL</code>: add key-value metadata to the image, common ones:
<a href="https://github.com/opencontainers/image-spec/blob/main/annotations.md">https://github.com/opencontainers/image-spec/blob/main/annotations.md</a></li>
<li><code>SHELL</code>: sets the shell, defaults to <code>["/bin/sh", "-c"]</code></li>
<li><code>STOPSIGNAL</code>: which signal should be sent to PID 1 on <code>docker stop</code> (defaults to
<code>SIGTERM</code>)</li>

</ul>

<p>
non-standard:
</p>
<ul>
<li><code>HEALTHCHECK</code>: command to check whether application in container is up</li>
<li><code>ONBUILD</code>: commands executed when using this image for building</li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="Dockerfile" data-line-numbers='|1|2|3|4-7|8|9|10|11|12|13-14|'>FROM registry.opensuse.org/opensuse/tumbleweed
COPY ./project/ /src/
ENV USER="geeko"
RUN zypper -n in openssh-clients; \
    ssh-keygen -t ed25519 -f /root/.ssh/id_ed25519 -N ""; \
    zypper -n rm --clean-deps openssh-clients; \
    zypper -n clean; rm -rf /var/log/lastlog;
VOLUME ["/src/data"]
WORKDIR /src/
EXPOSE 22
RUN useradd $USER
USER $USER
CMD ["echo hello"]
ENTRYPOINT ["/bin/bash", "-ce"]
</code></pre>
</div>
</section>
<section id="slide-org83870f2">
<h3 id="org83870f2">Docker Registry</h3>
<p class="fragment (appear)">
<img src="./media/registry.svg"/>
</p>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="bash" data-line-numbers='1|2|3'>docker pull registry.opensuse.org/opensuse/leap
docker pull registry.opensuse.org/opensuse/leap:15.6
docker pull registry.opensuse.org/opensuse/leap:15.5@sha256:a5ecb8286a6a1b695acb17e63f2702be29f2a72615ec10cfb4e427e2ebc9e8ad
</code></pre>
</div>

<aside class="notes">
<ul>
<li>central image storage, initially there was only <a href="https://hub.docker.com">Docker Hub</a> (nowadays many registries exist)</li>
<li>provides images via HTTP API</li>
<li>images identified via <code>repository:tag@digest</code></li>
<li>repository: name of the image</li>
<li>tag: something like a version, but really a free form field
only special value is <code>:latest</code>, pulled by default
you can have multiple images with the same tag üòí</li>
<li>digest: sha256 or sha512 hash of the image manifest</li>

</ul>

<p>
Digests:
some background: OCI registries return to <code>GET
/v2/&lt;repo&gt;/manifests/&lt;tag&gt;</code> either a <code>distribution.manifest</code> or a
<code>distribution.manifest.list</code> (that's a list of <code>distribution.manifest</code>), the digest
of an image is the sha256sum/sha512sum of the <code>distribution.manifest</code>
</p>

</aside>
</section>
<section id="slide-orge0c857c">
<h3 id="orge0c857c">Volumes</h3>
<aside class="notes">
<ul>
<li>data of a container exist in the (somewhat) temporary <code>upper</code> dir
&rArr; app data not persisted, must be mounted from external</li>
<li>bind mount</li>
<li>container volume (mount data provided by container engine, implementation
defined, but usually folder)</li>

<li>beware of SELinux! &rArr; (podman) launches container process with <code>container_t</code>
label, can only access files with <code>container_file_t</code> label (not present <b>anywhere</b>
by default) &rArr; <code>:Z</code> &amp; <code>:z</code> flags relabel volumes and add this flag,
see: <a href="https://www.redhat.com/en/blog/user-namespaces-selinux-rootless-containers">https://www.redhat.com/en/blog/user-namespaces-selinux-rootless-containers</a></li>

</ul>

</aside>

<p class="fragment (appear)">
<img src="./media/volumes.svg"/>
</p>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="bash" >docker run -v /vol/:/var/db/ -v logs:/var/log $img
</code></pre>
</div>
</section>
<section id="slide-org6ff0358">
<h3 id="org6ff0358">Entrypoint</h3>
<aside class="notes">
<ul>
<li>entrypoint is launched as PID 1 in pid namespace by OCI runtime
&rArr; everything in PID namespace becomes child process
&rArr; must forward signals to children &amp; reap them</li>

</ul>

<p>
This is why containers are not mini-VMs!
</p>

<ul>
<li>entrypoint should <b>not</b> be a shell &rArr; use the exec form and not the free form to
define the <code>ENTRYPOINT</code>, i.e.: <code>ENTRYPOINT ["//bin/foo//", "arg"]</code></li>
<li>entrypoint gets passed <code>CMD</code> as args by default</li>
<li>entrypoint should handle custom args, e.g. to launch a shell then</li>
<li>exec the actual container process, not just launch it as a subprocess (messes
up signal handling)</li>
<li>sign that signal handling is messed up:
<code>WARN[0010] StopSignal SIGTERM failed to stop container $FOO in 10 seconds, resorting to SIGKILL</code></li>

<li>preferably don't run a full init like systemd (hardly doable with docker)</li>
<li>general scheme: support configuration via environment variables</li>

</ul>

</aside>

<p class="fragment (appear)">
<img src="./media/entrypoint.svg"/>
</p>
</section>
<section id="slide-orgaee6a0d">
<h3 id="orgaee6a0d">Networking</h3>
<aside class="notes">
<ul>
<li>containers use bridge network by default:
can reach outside, but not other way around
ports need to be explicitly exposed (in bridge networking)</li>
<li>docker uses libnetwork to configure networking</li>
<li>CNI is container networking interface for rootfull networking, asigns IPs,
setup network interfaces &amp; routin, uses plugins
CNI is only used by docker in k8s mode with containerd</li>
<li>major networking modes:
<ul>
<li>bridge: NAT bridge to host net</li>
<li>host: use same network as host</li>
<li>none</li>
<li>overlay: connects multiple docker networks</li>
<li>macvlan: container gets its own network interface with unique MAC</li>
<li>ipvlan: container gets its own IP</li>

</ul></li>

</ul>

<p>
More information: <a href="https://web.archive.org/web/20240215124249/https://labs.iximiuz.com/tutorials/container-networking-from-scratch">https://web.archive.org/web/20240215124249/https://labs.iximiuz.com/tutorials/container-networking-from-scratch</a>
</p>

</aside>

<p class="fragment (appear)">
<img src="./media/networking.svg"/>
</p>
</section>
<section id="slide-org687e2a4">
<h3 id="org687e2a4">Best Practices</h3>
<aside class="notes">
<ul>
<li>ensure that layers don't leave stuff you don't need around</li>
<li>entrypoint should launch one primary binary not two or 15</li>
<li>configuration via env vars is nice :-)</li>
<li>entrypoint should either drop you into a shell or launch an app, depends on
the type of app</li>
<li>don't run a full init like systemd please</li>
<li>volumes are your friend to ensure data survive a container "death"</li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="Dockerfile" >RUN zypper -n in python3-pip; \
    pip install . ; \
    zypper -n rm --clean-deps gcc; zypper -n clean; \
    rm -rf {/target,}/var/log/{alternatives.log,lastlog,tallylog,zypper.log,zypp/history,YaST2}
</code></pre>
</div>

</section>
<section id="slide-org687e2a4-split">

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="shell" >$ podman run -e POSTGRES_PORT=1234 \
             -e POSTGRES_USER=pg \
                 my-app
$ podman run my-app bash
#
</code></pre>
</div>

<p class="fragment (appear)">
or:
</p>
<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="shell" >$ podman run my-app
#
</code></pre>
</div>

</section>
<section id="slide-org687e2a4-split">

<p>
Volumes are your friend:
</p>
<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="Dockerfile" >VOLUME ["/var/db/"]
# /var/db/ is now erased after each step!
</code></pre>
</div>

<p class="fragment (appear)">
use the exec-form:
</p>
<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="Dockerfile" >ENTRYPOINT ["/usr/bin/my-app", "-param", "value"]
</code></pre>
</div>
</section>
<section id="slide-orga1feb87">
<h3 id="orga1feb87">Podman</h3>
<aside class="notes">
<ul>
<li>docker uses split architecture: CLI run as user, daemon performs actual heavy
lifting</li>
<li>daemon runs as <b>root</b> by default! &rArr; everyone with access to the daemon is
effectively root!!</li>
<li>disagreements between RH &amp; Docker caused fork/new project: podman &amp; buildah</li>
<li>podman inner workings: <a href="https://www.redhat.com/en/blog/behind-scenes-podman">https://www.redhat.com/en/blog/behind-scenes-podman</a></li>

</ul>

</aside>

<p class="fragment (appear)">
Actually Docker
</p>

<p class="fragment (appear)">
<img src="./media/docker-daemon.svg"/>
</p>

</section>
<section id="slide-orga1feb87-split">

<p>
Podman
</p>

<p class="fragment (appear)">
<img src="./media/podman.svg"/>
</p>
</section>
<section id="slide-org822c89e">
<h3 id="org822c89e">Rootless Containers</h3>
<aside class="notes">
<ul>
<li>container runtime executes as non-root, container process launched as non-root</li>
<li>requires "relatively recent" kernel for user namespaces &amp; <code>newuidmap</code> /
<code>newgidmap</code> to be setuid root
&rArr; users in container are mapped to uids/gids from <code>/etc/subuid</code> &amp; <code>/etc/subgid</code></li>
<li>container has only your privileges, not more!</li>
<li>cannot expose ports &lt;= 1024</li>
<li>firewall needs to be manually punched through</li>
<li>rootless networking runs in userspace, e.g. libslirp/slirp4netns or pasta
due to kernel requiring root privileges to create network namespaces</li>

</ul>

</aside>

<ul>
<li class="fragment appear">container runs as non-root or a sub-uid of your user</li>
<li class="fragment appear">rootless networking runs in userspace</li>

</ul>
</section>
<section id="slide-orga6c1794">
<h3 id="orga6c1794">Security</h3>
<aside class="notes">
<ul>
<li>container can potentially do anything your user can
&rArr; docker socket is effectively root access!
<b>but</b> added complexity &amp; setuid binaries!</li>
<li>possible to break out of containers!</li>
<li>SELinux often can prevent access to host</li>

</ul>

</aside>

<ul>
<li class="fragment appear">container potentially as privileged as the user running it</li>
<li class="fragment appear">container breakout attacks exist</li>
<li class="fragment appear">SELinux is your friend</li>

</ul>
</section>
<section id="slide-org311275e">
<h3 id="org311275e">When to use Containers</h3>
<aside class="notes">
<ul>
<li>PID 1 signal handling model works well</li>

</ul>

</aside>

<ul>
<li class="fragment appear">Single-process applications</li>
<li class="fragment appear">"Works on my machine" problems</li>
<li class="fragment appear">Cloud/OS independent deployment</li>
<li class="fragment appear">Reproducible environments</li>

</ul>
</section>
<section id="slide-orge8240b7">
<h3 id="orge8240b7">When <b>NOT</b> to Use Containers</h3>
<ul>
<li class="fragment appear">High-performance I/O applications</li>
<li class="fragment appear">Legacy multi-process applications</li>
<li class="fragment appear">Desktop GUI applications</li>

</ul>
</section>
</section>
<section>
<section id="slide-org0a08ac2">
<h2 id="org0a08ac2">Container Orchestration</h2>
<aside class="notes">
<ul>
<li>each container = one binary &rArr; multiple containers for full app</li>
<li>need something to launch containers, monitor them &amp; tear down</li>
<li>preferably from config file &rArr; managed via git</li>

</ul>

</aside>

<p class="fragment (appear)">
<img src="./media/container-orchestration.svg"/>
</p>
</section>
<section id="slide-orgb821f06">
<h3 id="orgb821f06">docker-compose</h3>
<aside class="notes">
<ul>
<li>tool to launch multiple containers, defined via YAML file</li>
<li>first beta in Dec 2013, 1.0 Oct 2014
v2 Sep 2021 (rewrite in Go, changed format)</li>
<li>define your whole app in one file, supports every docker/container feature</li>
<li>supports service dependencies!</li>
<li>supports scaling but needs an ingress/load balancer then</li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="yaml" >services:
  app:
    build: .
    ports:
      - "8080:8080"
    volumes:
      - .:/src
    depends_on:
      db:
        condition: service_healthy
  db:
    image: registry.opensuse.org/opensuse/mariadb
    environment:
      - MARIADB_ALLOW_EMPTY_ROOT_PASSWORD=1
</code></pre>
</div>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="bash" >docker compose up
</code></pre>
</div>
</section>
<section id="slide-orgebba38c">
<h3 id="orgebba38c">Quadlet / <code>podman generate systemd</code></h3>
<aside class="notes">
<ul>
<li>original podman would generate systemd units</li>
<li>nowadays: quadlet - simplified systemd unit file like syntax
uses systemd generator to create systemd units</li>
<li>systemd manages lifecycle</li>

<li>see <code>man podman-systemd.unit</code> or
<a href="https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html">https://docs.podman.io/en/latest/markdown/podman-systemd.unit.5.html</a></li>

</ul>

</aside>

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="ini" >[Unit]
Description=TW container

[Container]
Image=registry.opensuse.org/opensuse/tumbleweed

# volume and network defined below in other configs
Volume=test.volume:/data
Network=test.network

Exec=sleep infinity

[Service]
Restart=always
TimeoutStartSec=900

[Install]
# Start by default on boot
WantedBy=multi-user.target default.target
</code></pre>
</div>
</section>
<section id="slide-org09af703">
<h3 id="org09af703">Kubernetes</h3>
<aside class="notes">
<ul>
<li>originally started as "Borg" at Google</li>
<li>open sourced 2014, donated to CNCF</li>
<li>declarative configuration via kubernetes yaml</li>
<li>self healing &amp; (auto) horizontal scaling</li>
<li>for microservice architecture (i.e. each container single app)</li>
<li>became quickly industry standard, kubernetes yaml nowadays supported by podman</li>

</ul>

<p>
architecture:
</p>
<ul>
<li>Control Plane (master components):
<ul>
<li>API Server: Front-end for the Kubernetes control plane</li>
<li>etcd: Consistent and highly-available key-value store for all cluster data</li>
<li>Scheduler: Assigns workloads to nodes</li>
<li>Controller Manager: Runs controller processes</li>
<li>Cloud Controller Manager: Integrates with cloud provider APIs</li>

</ul></li>
<li>Node Components:
<ul>
<li>Kubelet: Ensures containers are running in a pod</li>
<li>Container Runtime: Software responsible for running containers (Docker,
containerd, CRI-O)</li>
<li>Kube-proxy: Network proxy that maintains network rules on nodes</li>

</ul></li>

</ul>

<p>
Key Concepts:
</p>
<ul>
<li>Pods: Smallest deployable units, containing one or more containers</li>
<li>Services: Abstraction that defines a logical set of pods and a policy to access them</li>
<li>Deployments: Manage the deployment and scaling of a set of pods</li>
<li>ConfigMaps/Secrets: Ways to inject configuration into applications</li>
<li>Namespaces: Virtual clusters within a physical cluster</li>
<li>Persistent Volumes: Storage abstraction that outlives pod lifecycle</li>

</ul>

<p>
Common Patterns:
</p>
<ul>
<li>Sidecar: Helper containers that enhance the main container</li>
<li>Ambassador: Proxy local connections to external services</li>
<li>Adapter: Standardizes and normalizes output of the main container</li>
<li>Init Containers: Run before app containers, setting up dependencies</li>
<li>StatefulSets: For stateful applications requiring stable network identifiers and persistent storage</li>
<li>DaemonSets: Ensure that all nodes run a copy of a specific pod</li>
<li>Jobs/CronJobs: Run-to-completion and scheduled tasks</li>

<li>Kubernetes yaml</li>

</ul>

</aside>

<p class="fragment (appear)">
<img src="./media/Kubernetes.png" height="500px"/>
</p>

</section>
<section id="slide-org09af703-split">

<div class="org-src-container">

<pre  class="fragment (appear)"  ><code class="yaml" >apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-application
  labels:
    app: web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: web-container
        image: nginx:latest
        ports:
        - containerPort: 80
        resources:
          limits:
            cpu: "0.5"
            memory: "512Mi"
          requests:
            cpu: "0.2"
            memory: "256Mi"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
</code></pre>
</div>
</section>
</section>
<section>
<section id="slide-org52ef7bd">
<h2 id="org52ef7bd">Should I use Containers?</h2>
<aside class="notes">
<p>
pro:
</p>
<ul>
<li>infrastructure as code</li>
<li>data &amp; app separated</li>
<li>easier to test &amp; deploy</li>

</ul>

<p>
con:
</p>
<ul>
<li>added complexity</li>
<li>added overhead + space requirements</li>
<li>not suitable for all workloads</li>
<li>can be problematic in certain setups (rootless + ldap)</li>

</ul>

</aside>

<blockquote  class="fragment (appear)">
<p>
It depends
</p>
</blockquote>

</section>
<section id="slide-org52ef7bd-split">

<p class="fragment (appear)">
Ask yourself:
</p>

<ol>
<li class="fragment appear">Do I have environment consistency problems?</li>
<li class="fragment appear">Is my app a single process that I can isolate?</li>
<li class="fragment appear">Do I need to share/distribute my app environment?</li>
<li class="fragment appear">Can I separate data &amp; code in deployment?</li>
<li class="fragment appear">Am I willing to learn new deployment patterns?</li>

</ol>
</section>
</section>
<section>
<section id="slide-org1cdeda8">
<h2 id="org1cdeda8">Questions?</h2>
<p>
<img src="./media/qr.svg" height="300px"/>
</p>

<p>
<i class="fa-solid fa-person-chalkboard"></i> <a href="https://dcermak.github.io/container-images/container-images.html"><code>dcermak.github.io/container-images</code></a>
</p>
</section>
</section>
</div>
</div>
<script src="./node_modules/reveal.js/dist/reveal.js"></script>
<script src="./node_modules/reveal.js/plugin/highlight/highlight.js"></script>
<script src="./node_modules/reveal.js/plugin/notes/notes.js"></script>


<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
plugins: [RevealHighlight, RevealNotes, history],
transition: 'none', hash: true
});

</script>
</body>
</html>
